# ============================================================
# CALZADO J&R â€” Docker Compose (entorno de desarrollo)
# ============================================================
# Â¿QuÃ©?    Orquesta los 3 servicios del sistema: BD, BE y FE.
# Â¿Para?   Un Ãºnico `docker compose up -d` levanta todo el stack
#           con la configuraciÃ³n correcta y en el orden adecuado.
# Â¿Impacto? Elimina dependencias locales (Python, Node, PostgreSQL).
#           Todo corre dentro de contenedores aislados en una red
#           interna privada. Los puertos del host son solo para
#           acceso del desarrollador (navegador, psql, etc.).
#
# REQUISITO: Copiar .env.example â†’ .env y completar los valores.
#   cp .env.example .env
# ============================================================

services:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ğŸ˜ db â€” PostgreSQL 17
  # Â¿QuÃ©?    Motor de base de datos relacional.
  # Â¿Para?   Almacenar usuarios, roles y tokens de forma persistente.
  # Â¿Impacto? Tag "alpine" = imagen mÃ­nima (~10 MB vs ~200 MB full).
  #           El healthcheck bloquea al backend hasta que PostgreSQL
  #           estÃ© listo para aceptar conexiones (evita errores de
  #           "connection refused" al arrancar).
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  db:
    image: postgres:17-alpine
    container_name: calzado_jyr_db
    restart: unless-stopped

    environment:
      # Â¿Por quÃ© variables de entorno y no valores directos?
      # Seguridad: el docker-compose.yml se versiona en git.
      # Las credenciales reales van solo en el .env (ignorado por git).
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}

    ports:
      # Formato host:contenedor â€” solo expone al desarrollador local.
      # En producciÃ³n, no exponer este puerto (acceso solo desde la red interna).
      - "${DB_PORT:-5432}:5432"

    volumes:
      # Volumen nombrado: los datos sobreviven `docker compose down`.
      # Sin este volumen, cada `down` borra toda la BD.
      - calzado_jyr_data:/var/lib/postgresql/data
      # Scripts .sql en este directorio se ejecutan al crear el contenedor
      # por primera vez (orden alfabÃ©tico). Son idempotentes (IF NOT EXISTS).
      - ./db/init:/docker-entrypoint-initdb.d:ro

    healthcheck:
      # pg_isready verifica que PostgreSQL acepta conexiones TCP en el puerto.
      # interval: cada 10s intenta; retries: 5 intentos antes de "unhealthy".
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s

    networks:
      - calzado_jyr_net

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ğŸš€ be â€” Backend FastAPI
  # Â¿QuÃ©?    API REST construida con FastAPI + SQLAlchemy.
  # Â¿Para?   Procesar solicitudes HTTP del frontend y comunicarse
  #           con PostgreSQL a travÃ©s del ORM.
  # Â¿Impacto? `depends_on condition: service_healthy` garantiza que
  #           el backend NO arranca hasta que la BD estÃ© lista.
  #           El volumen ./be:/app habilita --reload: cada cambio
  #           en cÃ³digo Python reinicia el servidor automÃ¡ticamente.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  be:
    build:
      context: ./be
      dockerfile: Dockerfile
      # target: dev usa el stage "dev" del Dockerfile (hot-reload).
      # Cambiar a "prod" para despliegue (workers mÃºltiples, sin reload).
      target: dev
    container_name: calzado_jyr_be
    restart: unless-stopped

    depends_on:
      db:
        # service_healthy: espera al healthcheck exitoso, NO solo al start.
        # Diferencia crÃ­tica: el contenedor puede estar "running" pero
        # PostgreSQL aÃºn inicializando â€” service_healthy lo resuelve.
        condition: service_healthy

    environment:
      # Â¿Por quÃ© "db" como host y no "localhost"?
      # Dentro de la red Docker, los servicios se comunican por nombre.
      # "db" es el nombre del servicio definido arriba.
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}

      SECRET_KEY: ${SECRET_KEY}
      ALGORITHM: ${ALGORITHM:-HS256}
      ACCESS_TOKEN_EXPIRE_MINUTES: ${ACCESS_TOKEN_EXPIRE_MINUTES:-15}
      REFRESH_TOKEN_EXPIRE_DAYS: ${REFRESH_TOKEN_EXPIRE_DAYS:-7}

      MAIL_SERVER: ${MAIL_SERVER}
      MAIL_PORT: ${MAIL_PORT:-587}
      MAIL_USERNAME: ${MAIL_USERNAME}
      MAIL_PASSWORD: ${MAIL_PASSWORD}
      MAIL_FROM: ${MAIL_FROM}
      MAIL_FROM_NAME: ${MAIL_FROM_NAME}

      # El frontend necesita coincidir: CORS solo permitirÃ¡ esta URL.
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:5173}

    ports:
      - "${BE_PORT:-8000}:8000"

    volumes:
      # Montar el cÃ³digo fuente para hot-reload (solo en dev).
      # En producciÃ³n el cÃ³digo se copia dentro de la imagen (stage prod).
      - ./be:/app

    networks:
      - calzado_jyr_net

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ğŸŒ fe â€” Frontend React + Vite
  # Â¿QuÃ©?    Interfaz de usuario en React 19 + TypeScript + Tailwind.
  # Â¿Para?   Servir la aplicaciÃ³n web con hot-reload en desarrollo.
  # Â¿Impacto? Vite HMR (Hot Module Replacement) actualiza el navegador
  #           en milisegundos al guardar cualquier componente.
  #   - ./fe:/app â†’ cÃ³digo del host dentro del contenedor.
  #   - /app/node_modules â†’ volumen anÃ³nimo que preserva los
  #     node_modules instalados en la imagen (evita que el mount
  #     del host los sobreescriba con un directorio vacÃ­o).
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  fe:
    build:
      context: ./fe
      dockerfile: Dockerfile
      target: dev
    container_name: calzado_jyr_fe
    restart: unless-stopped

    depends_on:
      - be

    environment:
      # Vite expone variables VITE_* al cÃ³digo del navegador (public).
      # Apunta al backend: el navegador llama a localhost porque el
      # puerto del host estÃ¡ mapeado al contenedor be.
      VITE_API_URL: ${VITE_API_URL:-http://localhost:8000}

    ports:
      - "${FE_PORT:-5173}:5173"

    volumes:
      - ./fe:/app
      # Â¿Por quÃ© este volumen anÃ³nimo en node_modules?
      # El volumen ./fe:/app monta el directorio del host dentro del
      # contenedor. Si node_modules no existe en el host, Docker lo
      # crea vacÃ­o y tapa los que instalÃ³ npm durante el build.
      # Este volumen anÃ³nimo "protege" node_modules del override.
      - /app/node_modules

    networks:
      - calzado_jyr_net

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”— Red interna privada
# Â¿QuÃ©?    Red virtual bridge exclusiva para este proyecto.
# Â¿Para?   Aislar la comunicaciÃ³n entre servicios. NingÃºn
#           contenedor externo puede acceder a esta red.
# Â¿Impacto? db NO es accesible desde internet, solo desde be.
#           Principio de mÃ­nimo privilegio en redes de contenedores.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
networks:
  calzado_jyr_net:
    driver: bridge

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“¦ VolÃºmenes nombrados
# Â¿QuÃ©?    Almacenamiento persistente gestionado por Docker.
# Â¿Para?   Los datos de PostgreSQL sobreviven `docker compose down`.
# Â¿Impacto? `docker compose down -v` BORRA los datos (Ãºtil para reset).
#           `docker compose down` sin -v los conserva.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
volumes:
  calzado_jyr_data:
